"""
Unit tests for the database_utils module in the Neighbour Approved application.

This module tests all functions and constants defined in the database_utils.py file,
ensuring that SQLAlchemy column and constraint helpers behave as intended and
that phone number validation is correctly enforced.

Key components tested:
- create_foreign_key_column
- create_string_column
- create_boolean_column
- create_unique_constraint
- create_check_constraint
- validate_phone_number
- create_phone_constraint
- create_email_constraint

Typical usage example:
    pytest tests/unit/test_database_utils.py

Dependencies:
    - pytest
    - SQLAlchemy
    - The database_utils module under test
"""

import pytest
from sqlalchemy import Table, MetaData, Column, Integer, String, Boolean, text
from sqlalchemy.dialects.sqlite import dialect as sqlite_dialect
from sqlalchemy.schema import CreateTable
from sqlalchemy.exc import OperationalError
from app.db.database_utils import (
    DEFAULT_STRING_LENGTH,
    SHORT_STRING_LENGTH,
    MEDIUM_STRING_LENGTH,
    LONG_STRING_LENGTH,
    NAME_LENGTH,
    DESCRIPTION_LENGTH,
    COMMENT_LENGTH,
    PHONE_LENGTH,
    EMAIL_LENGTH,
    POSTAL_LENGTH,
    SLUG_LENGTH,
    create_foreign_key_column,
    create_string_column,
    create_boolean_column,
    create_unique_constraint,
    create_check_constraint,
    validate_phone_number,
    create_phone_constraint,
    create_email_constraint,
)


def test_constants():
    """
    Test that column length constants are set to their expected values.
    """
    assert DEFAULT_STRING_LENGTH == 255
    assert SHORT_STRING_LENGTH == 50
    assert MEDIUM_STRING_LENGTH == 100
    assert LONG_STRING_LENGTH == 500
    assert NAME_LENGTH == 100
    assert DESCRIPTION_LENGTH == 255
    assert COMMENT_LENGTH == 500
    assert PHONE_LENGTH == 20
    assert EMAIL_LENGTH == 255
    assert POSTAL_LENGTH == 200
    assert SLUG_LENGTH == 100


def test_create_foreign_key_column_default_name():
    """
    Test that create_foreign_key_column creates a column with default naming.

    Verifies the column name is generated by stripping the trailing 's'
    from the target_table name and appending '_id', unless otherwise specified.
    """
    col = create_foreign_key_column("users")
    assert isinstance(col, Column)
    assert col.name == "user_id"
    assert col.foreign_keys

    fk = list(col.foreign_keys)[0]
    # Instead of referencing fk.column.table.name, use `target_fullname`:
    assert fk.target_fullname == "users.id"


def test_create_foreign_key_column_custom_name():
    """
    Test that create_foreign_key_column uses a custom name if provided.

    Verifies that the column name can be overridden via the 'name' parameter.
    """
    col = create_foreign_key_column(
        "customers", name="external_id", ondelete="SET NULL"
    )
    assert col.name == "external_id"
    fk = list(col.foreign_keys)[0]
    # Instead of 'fk.column.table.name', we use 'fk.target_fullname':
    assert fk.target_fullname == "customers.id"
    # If you prefer, you can check _colspec:
    # assert fk._colspec == "customers.id"


def test_create_string_column_defaults():
    """
    Test that create_string_column creates a string column with default options.

    Asserts the default length, nullability, uniqueness, and indexing.
    """
    col = create_string_column()
    assert col.type.length == 255
    assert col.nullable is True
    assert col.unique is False
    assert col.index is False


def test_create_string_column_custom():
    """
    Test that create_string_column accepts custom arguments for length, nullability, uniqueness, and indexing.
    """
    col = create_string_column(
        length=100, nullable=False, unique=True, index=True, doc="User email field"
    )
    assert col.type.length == 100
    assert col.nullable is False
    assert col.unique is True
    assert col.index is True
    assert col.doc == "User email field"


def test_create_boolean_column_defaults():
    """
    Test that create_boolean_column creates a boolean column with default values.
    """
    col = create_boolean_column()
    assert col.type.python_type is bool
    assert col.default.arg is False
    assert col.nullable is False


def test_create_boolean_column_custom():
    """
    Test that create_boolean_column accepts custom arguments such as default and nullability.
    """
    col = create_boolean_column(default=True, nullable=True, doc="Active status")
    assert col.default.arg is True
    assert col.nullable is True
    assert col.doc == "Active status"


def test_create_unique_constraint_no_name():
    """
    Test that create_unique_constraint creates a unique constraint with
    an auto-generated name, verifying via the Constraint object rather than SQL text.
    """
    metadata = MetaData()

    # Create columns to match your constraint names
    col1 = Column("field1", Integer)
    col2 = Column("field2", Integer)

    uc = create_unique_constraint("field1", "field2")
    test_table = Table("test_table_constraint", metadata, col1, col2, uc)

    assert uc.name == "uq_field1_field2"
    # We now have real Column objects in the constraint
    assert uc.columns.contains_column(col1)
    assert uc.columns.contains_column(col2)

    # Confirm the table has exactly one UniqueConstraint, which is ours
    unique_constraints = [c for c in test_table.constraints if isinstance(c, type(uc))]
    assert len(unique_constraints) == 1
    assert unique_constraints[0].name == "uq_field1_field2"


def test_create_unique_constraint_with_name():
    """
    Test that create_unique_constraint uses a provided name if specified.
    """
    uc = create_unique_constraint("field1", "field2", name="uq_custom_name")
    assert uc.name == "uq_custom_name"


def test_create_check_constraint_no_name():
    """
    Test that create_check_constraint creates a check constraint without a custom name.
    """
    cc = create_check_constraint("age > 18")
    assert cc.sqltext.text == "age > 18"
    # The name can be None if not provided; that's acceptable.


def test_create_check_constraint_with_name():
    """
    Test that create_check_constraint uses a provided name if specified.
    """
    cc = create_check_constraint(
        "score >= 0 AND score <= 100", name="check_score_range"
    )
    assert cc.name == "check_score_range"
    assert cc.sqltext.text == "score >= 0 AND score <= 100"


@pytest.mark.parametrize(
    "input_value,expected",
    [
        (None, None),
        ("", None),
        ("1234567890", "1234567890"),  # exactly 10 digits
        ("+1 (234) 567-8901", "12345678901"),
    ],
)
def test_validate_phone_number_valid(input_value, expected):
    """
    Test that validate_phone_number returns the expected formatted digits for valid phone numbers.
    """
    assert validate_phone_number(input_value) == expected


@pytest.mark.parametrize(
    "input_value",
    [
        "123456789",  # only 9 digits
        "1234567890123456",  # 16 digits
        "abcdef",  # no digits
    ],
)
def test_validate_phone_number_invalid(input_value):
    """
    Test that validate_phone_number raises ValueError for invalid phone numbers.
    """
    with pytest.raises(ValueError):
        validate_phone_number(input_value)


def test_create_phone_constraint():
    """
    Test that create_phone_constraint returns a correct CheckConstraint for phone numbers.
    """
    pc = create_phone_constraint("phone_col")
    # Checking partial text, the full expression may differ by SQL dialect.
    assert "phone_col" in pc.sqltext.text
    assert "BETWEEN 10 AND 15" in pc.sqltext.text
    assert pc.name == "valid_phone_col_format"


def test_create_email_constraint():
    """
    Test that create_email_constraint returns a correct CheckConstraint for email addresses.
    """
    ec = create_email_constraint("email_col")
    assert "email_col" in ec.sqltext.text
    assert "~*" in ec.sqltext.text  # case-insensitive regex operator
    assert ec.name == "valid_email_col_format"


def test_foreign_key_column_in_table():
    """
    Test that a foreign key column can be added to a table and validated.

    We attach the column to a table, ensure the table is recognized by metadata,
    and confirm that the column's foreign key points to users.id.
    """
    metadata = MetaData()
    user_fk_column = create_foreign_key_column("users")
    test_table = Table("test_table", metadata, user_fk_column)

    assert test_table.name == "test_table"
    assert "test_table" in metadata.tables
    assert metadata.tables["test_table"] is test_table

    # Check the foreign key was created as expected
    assert "user_id" in test_table.c
    fk = list(test_table.c.user_id.foreign_keys)[0]
    assert fk.target_fullname == "users.id"


def test_string_column_in_table():
    """
    Test that a string column can be added to a table and validated (basic structural check).
    """
    metadata = MetaData()
    name_col = create_string_column(length=50, unique=True)

    # Give the column a name:
    name_col.name = "my_string_col"

    test_table = Table("test_table_string", metadata, name_col)
    # Now it's a valid named column in the table

    # You can confirm it's recognized:
    assert "my_string_col" in test_table.c


def test_boolean_column_in_table():
    """
    Test that a boolean column can be added to a table and validated (basic structural check).
    """
    metadata = MetaData()
    active_col = create_boolean_column(default=True, doc="Is active user?")

    # Assign a name so SQLAlchemy knows how to place it in the table
    active_col.name = "is_active"

    test_table = Table("test_table_bool", metadata, active_col)
    # At this point, test_table.c.is_active references our boolean column

    # Optionally, check the column exists:
    assert "is_active" in test_table.c
    assert test_table.c.is_active.type.python_type is bool


def test_constraint_in_table():
    """
    Test that a unique constraint can be added to a table and validated
    by inspecting compiled SQL on a real dialect (SQLite).
    """
    metadata = MetaData()

    col1 = Column("col_1", String(10))
    col2 = Column("col_2", String(10))
    ucon = create_unique_constraint("col_1", "col_2")

    test_table = Table("test_table_constraint", metadata, col1, col2, ucon)

    # Build the CREATE TABLE statement explicitly
    create_stmt = str(
        CreateTable(test_table).compile(
            dialect=sqlite_dialect(), compile_kwargs={"literal_binds": True}
        )
    )

    assert "CREATE TABLE test_table_constraint" in create_stmt
    assert "col_1" in create_stmt
    assert "col_2" in create_stmt
    assert "UNIQUE" in create_stmt
