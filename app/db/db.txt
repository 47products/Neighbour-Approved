
<<< Processing file: ./config.py >>>

"""
Configuration management module.

This module implements the application's configuration management system using
Pydantic V2's settings management. It provides a secure and validated approach to
handling environment variables and sensitive configuration data while maintaining
flexibility for different deployment environments.

The module enforces proper validation of configuration values and provides clear
error messages when required settings are missing or invalid. It integrates with
environment variables and supports multiple configuration profiles for different
deployment scenarios.
"""

from functools import lru_cache
from pydantic import (
    Field,
    PostgresDsn,
    SecretStr,
    field_validator,
    model_validator,
)
from pydantic_settings import BaseSettings


class DatabaseSettings(BaseSettings):
    """
    Database-specific configuration settings.

    This class manages database connection parameters and credentials,
    ensuring proper validation and secure handling of sensitive information.

    Attributes:
        POSTGRES_USER: Database username
        POSTGRES_PASSWORD: Database password (stored securely)
        POSTGRES_HOST: Database host address
        POSTGRES_PORT: Database port number
        POSTGRES_DB: Database name
        ENABLE_SQL_ECHO: Flag to enable SQL query logging
        MIN_POOL_SIZE: Minimum database connection pool size
        MAX_POOL_SIZE: Maximum database connection pool size
        POOL_RECYCLE_SECONDS: Connection recycle interval
    """

    POSTGRES_USER: str = Field(
        ...,
        description="Database username",
    )
    POSTGRES_PASSWORD: SecretStr = Field(
        ...,
        description="Database password",
    )
    POSTGRES_HOST: str = Field(
        ...,
        description="Database host address",
    )
    POSTGRES_PORT: int = Field(
        default=5432,
        description="Database port number",
    )
    POSTGRES_DB: str = Field(
        ...,
        description="Database name",
    )
    ENABLE_SQL_ECHO: bool = Field(
        default=False,
        description="Enable SQL query logging",
    )
    MIN_POOL_SIZE: int = Field(
        default=5,
        description="Minimum database connection pool size",
    )
    MAX_POOL_SIZE: int = Field(
        default=20,
        description="Maximum database connection pool size",
    )
    POOL_RECYCLE_SECONDS: int = Field(
        default=1800,
        description="Connection recycle interval in seconds",
    )

    @field_validator("POSTGRES_PORT")
    @classmethod
    def validate_port(cls, v: int) -> int:
        """
        Validate that the port number is within a valid range.

        Args:
            v: Port number to validate

        Returns:
            int: Validated port number

        Raises:
            ValueError: If port number is invalid
        """
        if not 1 <= v <= 65535:
            raise ValueError("Port number must be between 1 and 65535")
        return v

    @field_validator("MIN_POOL_SIZE", "MAX_POOL_SIZE")
    @classmethod
    def validate_pool_size(cls, v: int) -> int:
        """
        Validate that pool sizes are positive integers.

        Args:
            v: Pool size to validate

        Returns:
            int: Validated pool size

        Raises:
            ValueError: If pool size is invalid
        """
        if v < 1:
            raise ValueError("Pool size must be positive")
        return v

    @model_validator(mode="after")
    def validate_pool_sizes(self) -> "DatabaseSettings":
        """
        Validate that minimum pool size is less than maximum.

        Returns:
            DatabaseSettings: The validated settings instance

        Raises:
            ValueError: If pool size configuration is invalid
        """
        if self.MIN_POOL_SIZE > self.MAX_POOL_SIZE:
            raise ValueError(
                "Minimum pool size cannot be greater than maximum pool size"
            )
        return self


class Settings(DatabaseSettings):
    """
    Main application configuration settings.

    This class extends database settings with additional application-wide
    configuration parameters. It provides a centralized location for all
    configuration management while ensuring proper validation and security.

    Attributes:
        APPLICATION_NAME: Name of the application
        ENVIRONMENT: Deployment environment (development, staging, production)
        DEBUG: Debug mode flag
        API_PREFIX: Prefix for all API endpoints
        CORS_ORIGINS: Allowed CORS origins
    """

    APPLICATION_NAME: str = Field(
        "Neighbour Approved",
        description="Application name",
    )
    ENVIRONMENT: str = Field(
        "development",
        description="Deployment environment",
    )
    DEBUG: bool = Field(
        False,
        description="Debug mode flag",
    )
    API_PREFIX: str = Field(
        "/api",
        description="API endpoint prefix",
    )
    CORS_ORIGINS: list[str] = Field(
        default_factory=list,
        description="Allowed CORS origins",
    )

    model_config = {
        "env_file": ".env",
        "env_file_encoding": "utf-8",
        "case_sensitive": True,
    }

    @property
    def database_url(self) -> PostgresDsn:
        """
        Construct the database URL from individual settings.

        Returns:
            PostgresDsn: Validated database URL
        """
        return PostgresDsn.build(
            scheme="postgresql",
            username=self.POSTGRES_USER,
            password=self.POSTGRES_PASSWORD.get_secret_value(),
            host=self.POSTGRES_HOST,
            port=self.POSTGRES_PORT,
            path=self.POSTGRES_DB,
        )

    @field_validator("ENVIRONMENT")
    @classmethod
    def validate_environment(cls, v: str) -> str:
        """
        Validate the deployment environment setting.

        Args:
            v: Environment name to validate

        Returns:
            str: Validated environment name

        Raises:
            ValueError: If environment name is invalid
        """
        allowed_environments = {"development", "staging", "production"}
        if v.lower() not in allowed_environments:
            raise ValueError(
                f"Environment must be one of: {', '.join(allowed_environments)}"
            )
        return v.lower()

    @field_validator("API_PREFIX")
    @classmethod
    def validate_api_prefix(cls, v: str) -> str:
        """
        Validate the API prefix format.

        Args:
            v: API prefix to validate

        Returns:
            str: Validated API prefix

        Raises:
            ValueError: If API prefix format is invalid
        """
        if not v.startswith("/"):
            v = f"/{v}"
        return v.rstrip("/")


@lru_cache()
def get_settings() -> Settings:
    """
    Create and cache application settings.

    This function provides a cached instance of the settings class to avoid
    repeated environment variable lookups and validation. The cache is
    particularly useful in web applications where configuration is frequently
    accessed.

    Returns:
        Settings: Cached settings instance
    """
    return Settings()


<<< Processing file: ./database.py >>>

"""
Database configuration and engine setup module.

This module establishes the core database configuration for the application,
including the SQLAlchemy engine setup, session management, and declarative base
configuration. It implements connection pooling and proper engine configuration
for optimal database performance and reliability.

The module integrates with the application's configuration management system
to handle database credentials and connection parameters securely while
providing flexibility for different deployment environments.
"""

from typing import Any, Dict
from sqlalchemy import create_engine, event, Engine
from sqlalchemy.engine import URL
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.orm import declarative_base, sessionmaker, Session
from sqlalchemy.pool import QueuePool

from app.db.config import Settings

# Initialize settings from environment
settings = Settings()

# Configure database connection parameters
connection_args: Dict[str, Any] = {
    "pool_pre_ping": True,  # Enable connection health checks
    "pool_size": 5,  # Initial pool size
    "max_overflow": 10,  # Maximum number of connections above pool_size
    "pool_timeout": 30,  # Timeout for getting connection from pool
    "pool_recycle": 1800,  # Recycle connections after 30 minutes
    "echo": settings.ENABLE_SQL_ECHO,  # SQL query logging
    "poolclass": QueuePool,  # Use QueuePool for connection pooling
}

# Create the database URL
database_url = URL.create(
    drivername="postgresql+psycopg2",
    username=settings.POSTGRES_USER,
    password=settings.POSTGRES_PASSWORD.get_secret_value(),
    host=settings.POSTGRES_HOST,
    port=settings.POSTGRES_PORT,
    database=settings.POSTGRES_DB,
)

# Create the SQLAlchemy engine
engine = create_engine(
    database_url,
    **connection_args,
)

# Create session factory
SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine,
)

# Create declarative base for models
Base = declarative_base()


@event.listens_for(Engine, "connect")
def set_postgres_timezone(
    dbapi_connection: Any,
    _connection_record: Any,
) -> None:
    """
    Set timezone to UTC for all database connections.

    This event listener ensures that all database connections use UTC
    timezone for consistent datetime handling across the application.

    Args:
        dbapi_connection: The raw database connection
        connection_record: Connection pool record
    """
    cursor = dbapi_connection.cursor()
    cursor.execute("SET TIME ZONE 'UTC'")
    cursor.close()


@event.listens_for(Engine, "connect")
def set_search_path(
    dbapi_connection: Any,
    _connection_record: Any,
) -> None:
    """
    Set the schema search path for all database connections.

    This event listener configures the schema search path to ensure
    proper schema resolution for database operations.

    Args:
        dbapi_connection: The raw database connection
        connection_record: Connection pool record
    """
    cursor = dbapi_connection.cursor()
    cursor.execute("SET search_path TO public")
    cursor.close()


def get_engine() -> Engine:
    """
    Get the configured database engine instance.

    This function provides access to the database engine with all
    connection pooling and configuration settings properly applied.

    Returns:
        Engine: Configured SQLAlchemy engine instance
    """
    return engine


def create_session() -> Session:
    """
    Create a new database session.

    This function creates a new session using the configured session
    factory. It should be used when explicit session creation is needed
    outside of the dependency injection system.

    Returns:
        Session: New database session instance
    """
    return SessionLocal()


def verify_database_connection() -> bool:
    """
    Verify that the database connection is working.

    This function attempts to establish a database connection and
    execute a simple query to verify database accessibility.

    Returns:
        bool: True if connection is successful, False otherwise

    Raises:
        SQLAlchemyError: If database connection fails
    """
    try:
        with create_session() as session:
            session.execute("SELECT 1")
        return True
    except Exception as e:
        # Add specific exception handling

        if isinstance(e, SQLAlchemyError):
            return False
        raise


def init_database() -> None:
    """
    Initialize the database with required tables and initial data.

    This function creates all database tables based on the defined models
    and performs any necessary initialization steps. It should be called
    during application startup.
    """
    Base.metadata.create_all(bind=engine)


<<< Processing file: ./session.py >>>

"""
Database session management module.

This module provides utilities for managing database sessions within the application,
ensuring proper handling of database connections and transactions. It implements
a dependency that can be used in FastAPI endpoints to obtain database sessions
that are automatically closed after use.

The module follows best practices for connection management, including proper
resource cleanup and error handling. It provides type-safe session handling
while maintaining efficient connection pooling through SQLAlchemy.
"""

from typing import Generator, Any
from contextlib import contextmanager
from sqlalchemy.orm import Session
from fastapi import HTTPException, status

from app.db.database import SessionLocal


def get_db() -> Generator[Session, Any, None]:
    """
    FastAPI dependency that provides a database session and ensures proper cleanup.

    This dependency yields a database session that can be used within FastAPI
    endpoint functions. The session is automatically closed when the endpoint
    processing is complete, ensuring proper resource management even in case
    of errors.

    Yields:
        Session: An active database session from the connection pool

    Raises:
        HTTPException: If a database error occurs during session creation
    """
    db = SessionLocal()
    try:
        yield db
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Database error occurred",
        ) from e
    finally:
        db.close()


@contextmanager
def session_scope() -> Generator[Session, Any, None]:
    """
    Context manager for handling database sessions in background tasks.

    This context manager provides a database session with automatic commit/rollback
    handling. It should be used for database operations outside of HTTP request
    handling, such as background tasks or scheduled jobs.

    Yields:
        Session: An active database session

    Example:
        with session_scope() as session:
            session.add(some_object)
            # Session is automatically committed if no exception occurs
    """
    session = SessionLocal()
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()


class DatabaseSessionManager:
    """
    Manager class for handling database sessions with explicit lifecycle control.

    This class provides methods for obtaining and managing database sessions
    with explicit control over the session lifecycle. It's useful for cases
    where the automatic session management through dependencies or context
    managers isn't suitable.

    Example:
        session_manager = DatabaseSessionManager()
        session = session_manager.get_session()
        try:
            # Use session
            session_manager.commit(session)
        except Exception:
            session_manager.rollback(session)
        finally:
            session_manager.close(session)
    """

    @staticmethod
    def get_session() -> Session:
        """
        Create and return a new database session.

        Returns:
            Session: A new database session
        """
        return SessionLocal()

    @staticmethod
    def commit(session: Session) -> None:
        """
        Commit the current transaction on the given session.

        Args:
            session: The database session to commit
        """
        session.commit()

    @staticmethod
    def rollback(session: Session) -> None:
        """
        Roll back the current transaction on the given session.

        Args:
            session: The database session to roll back
        """
        session.rollback()

    @staticmethod
    def close(session: Session) -> None:
        """
        Close the given database session.

        Args:
            session: The database session to close
        """
        session.close()


<<< Processing file: ./types.py >>>

# pylint: disable=too-many-ancestors
"""Database type definitions for SQLAlchemy models."""

from datetime import datetime, timezone
from enum import Enum
from typing import Any, Optional, Union
from sqlalchemy import CheckConstraint, DateTime, TypeDecorator


class TZDateTime(TypeDecorator):
    """Custom SQLAlchemy type that enforces timezone-aware datetime fields."""

    impl = DateTime
    cache_ok = True

    def process_literal_param(self, value: Any, dialect: Any) -> Optional[str]:
        """Process literal parameters for the database."""
        if value is not None:
            return f"TIMESTAMP '{value}'"
        return None

    @property
    def python_type(self) -> type:
        """Return the Python type handled by this type decorator."""
        return datetime

    def process_bind_param(
        self, value: Optional[Union[datetime, Any]], dialect: Any
    ) -> Optional[datetime]:
        if value is not None:
            if not value.tzinfo:
                raise ValueError(
                    "Timezone aware datetime is required. Please provide a "
                    "datetime with tzinfo."
                )
            return value.astimezone(timezone.utc)
        return value

    def process_result_value(
        self, value: Optional[Union[datetime, Any]], dialect: Any
    ) -> Optional[datetime]:
        if value is not None:
            return value.replace(tzinfo=timezone.utc)
        return value


class PrivacyLevel(str, Enum):
    """Enumeration for community privacy levels."""

    PUBLIC = "public"
    PRIVATE = "private"
    INVITATION_ONLY = "invitation_only"

    @classmethod
    def values(cls):
        """Return all valid enum values."""
        return [e.value for e in cls]


def create_email_check_constraint(column_name: str) -> CheckConstraint:
    """Create a check constraint for email format validation."""
    return CheckConstraint(
        f"{column_name} IS NULL OR "
        f"{column_name} ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+[.][A-Za-z]{{2,}}$'",
        name=f"valid_{column_name}_format",
    )


<<< Processing file: ./models/service.py >>>

"""Service model definition module."""

from __future__ import annotations

from dataclasses import dataclass
from decimal import Decimal
from typing import TYPE_CHECKING, List, Optional

from sqlalchemy import (
    Boolean,
    Index,
    Integer,
    String,
    ForeignKey,
    Numeric,
    text,
)
from sqlalchemy.orm import Mapped, relationship, mapped_column

from app.db.database import Base
from app.db.utils import (
    COMMENT_LENGTH,
    SHORT_STRING_LENGTH,
)
from app.db.models.mixins import (
    TimestampMixin,
    ActiveMixin,
    NameMixin,
)
from app.db.models.associations import contact_services

if TYPE_CHECKING:
    from app.db.models.category import Category
    from app.db.models.contact import Contact


@dataclass
class ServiceCreate:
    """Data transfer object for creating a new Service."""

    name: str
    category_id: int
    description: Optional[str] = None
    base_price: Optional[Decimal] = None
    price_unit: Optional[str] = None
    requires_consultation: bool = False
    is_remote_available: bool = False
    minimum_hours: Optional[int] = None
    maximum_hours: Optional[int] = None


# pylint: disable=too-many-instance-attributes
class Service(TimestampMixin, ActiveMixin, NameMixin, Base):
    """
    Service model for offerings that contacts can provide.

    Represents specific services that can be offered by contacts. Each service
    belongs to a category and includes detailed pricing and availability information.

    Attributes:
        id (int): Unique identifier
        name (str): Service name
        description (str, optional): Detailed description
        category_id (int): ID of category
        base_price (Decimal, optional): Base price
        price_unit (str, optional): Unit for price (e.g., 'hour', 'project')
        minimum_hours (int, optional): Minimum booking duration
        maximum_hours (int, optional): Maximum booking duration
        requires_consultation (bool): Whether consultation is required
        is_remote_available (bool): Whether service can be provided remotely
        is_active (bool): Whether service is currently available

    Relationships:
        category: Service category
        contacts: Providers offering this service
    """

    __tablename__ = "services"

    id: Mapped[int] = mapped_column(primary_key=True)
    category_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("categories.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    base_price: Mapped[Optional[Decimal]] = mapped_column(
        Numeric(10, 2),
        comment="Base price for the service",
    )
    price_unit: Mapped[Optional[str]] = mapped_column(
        String(SHORT_STRING_LENGTH),
        comment="Unit of measurement for the price",
    )
    minimum_hours: Mapped[Optional[int]] = mapped_column(
        Integer,
        comment="Minimum duration in hours",
    )
    maximum_hours: Mapped[Optional[int]] = mapped_column(
        Integer,
        comment="Maximum duration in hours",
    )
    requires_consultation: Mapped[bool] = mapped_column(
        Boolean,
        default=False,
        nullable=False,
    )
    is_remote_available: Mapped[bool] = mapped_column(
        Boolean,
        default=False,
        nullable=False,
    )

    # Override from NameMixin to specify different length
    description: Mapped[Optional[str]] = mapped_column(
        String(COMMENT_LENGTH),
        doc="Detailed service description",
    )

    # Relationships
    category: Mapped[Category] = relationship(
        "Category",
        back_populates="services",
        lazy="joined",
    )
    contacts: Mapped[List[Contact]] = relationship(
        "Contact",
        secondary=contact_services,
        back_populates="services",
        lazy="selectin",
        order_by="Contact.contact_name",
    )

    __table_args__ = (
        # Existing constraints remain...
        # Optimize price-based service searches
        # This partial index only includes active services
        Index(
            "idx_services_price",
            "category_id",
            "base_price",
            "is_active",
            postgresql_where=text("is_active = true"),
        ),
        # Optimize availability-based queries
        Index(
            "idx_services_availability",
            "is_remote_available",
            "requires_consultation",
            "is_active",
            postgresql_where=text("is_active = true"),
        ),
    )

    @classmethod
    def create(cls, data: ServiceCreate) -> Service:
        """Create a new Service from ServiceCreate data."""
        return cls(**data.__dict__)

    def __repr__(self) -> str:
        """Return string representation."""
        return f"Service(id={self.id}, name={self.name})"

    def get_formatted_price(self) -> Optional[str]:
        """Get formatted price string."""
        if self.base_price is None or self.price_unit is None:
            return None
        return f"${self.base_price:.2f} per {self.price_unit}"

    def calculate_price(self, hours: Optional[int] = None) -> Optional[Decimal]:
        """
        Calculate total price for duration.

        Args:
            hours: Number of hours requested

        Returns:
            Calculated price or None if pricing unavailable

        Raises:
            ValueError: If hours outside allowed range
        """
        if self.base_price is None:
            return None

        if self.price_unit != "hour" or hours is None:
            return self.base_price

        if self.minimum_hours and hours < self.minimum_hours:
            raise ValueError(f"Minimum booking duration is {self.minimum_hours} hours")

        if self.maximum_hours and hours > self.maximum_hours:
            raise ValueError(f"Maximum booking duration is {self.maximum_hours} hours")

        return self.base_price * Decimal(str(hours))

    def is_available_for_duration(self, hours: int) -> bool:
        """Check if service can be booked for duration."""
        if not self.is_active:
            return False

        if self.minimum_hours and hours < self.minimum_hours:
            return False

        if self.maximum_hours and hours > self.maximum_hours:
            return False

        return True

    @property
    def duration_constraints(self) -> Optional[str]:
        """Get human-readable duration constraints."""
        if not (self.minimum_hours or self.maximum_hours):
            return None

        if self.minimum_hours and self.maximum_hours:
            return f"Duration: {self.minimum_hours}-{self.maximum_hours} hours"

        if self.minimum_hours:
            return f"Minimum duration: {self.minimum_hours} hours"

        return f"Maximum duration: {self.maximum_hours} hours"


<<< Processing file: ./models/user.py >>>

"""User model definition module."""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from typing import TYPE_CHECKING, List, Optional

from sqlalchemy import String
from sqlalchemy.orm import Mapped, relationship, mapped_column

from app.db.database import Base
from app.db.models.mixins import TimestampMixin, ActiveMixin
from app.db.models.associations import (
    user_roles,
    user_communities,
)
from app.db.utils import (
    EMAIL_LENGTH,
    SHORT_STRING_LENGTH,
    POSTAL_LENGTH,
    PHONE_LENGTH,
    create_email_constraint,
    create_phone_constraint,
)

if TYPE_CHECKING:
    from app.db.models.contact import Contact
    from app.db.models.role import Role
    from app.db.models.community import Community
    from app.db.models.contact_endorsement import ContactEndorsement


@dataclass
class UserCreate:
    """Data transfer object for creating a new User."""

    email: str
    password: str
    first_name: str
    last_name: str
    mobile_number: Optional[str] = None
    postal_address: Optional[str] = None
    physical_address: Optional[str] = None
    country: Optional[str] = None


class User(TimestampMixin, ActiveMixin, Base):
    """
    User model for system authentication and authorization.

    Central entity for user management, containing personal information,
    authentication details, and relationships with other entities.

    Attributes:
        id (int): Unique identifier
        email (str): Email address (unique)
        password (str): Hashed password
        first_name (str): First name
        last_name (str): Last name
        mobile_number (str, optional): Mobile phone
        postal_address (str, optional): Mailing address
        physical_address (str, optional): Physical location
        country (str, optional): Country of residence
        email_verified (bool): Whether email is verified
        last_login (datetime, optional): Last login timestamp

    Relationships:
        contacts: User's contacts
        roles: Assigned roles
        communities: Member communities
        contact_endorsements: Given endorsements
        owned_communities: Owned communities
    """

    __tablename__ = "users"

    id: Mapped[int] = mapped_column(primary_key=True)
    email: Mapped[str] = mapped_column(
        String(EMAIL_LENGTH),
        unique=True,
        index=True,
        nullable=False,
    )
    password: Mapped[str] = mapped_column(
        String(EMAIL_LENGTH),
        nullable=False,
    )
    first_name: Mapped[str] = mapped_column(
        String(SHORT_STRING_LENGTH),
        nullable=False,
    )
    last_name: Mapped[str] = mapped_column(
        String(SHORT_STRING_LENGTH),
        nullable=False,
    )
    mobile_number: Mapped[Optional[str]] = mapped_column(
        String(PHONE_LENGTH),
    )
    postal_address: Mapped[Optional[str]] = mapped_column(
        String(POSTAL_LENGTH),
    )
    physical_address: Mapped[Optional[str]] = mapped_column(
        String(POSTAL_LENGTH),
    )
    country: Mapped[Optional[str]] = mapped_column(
        String(SHORT_STRING_LENGTH),
    )
    email_verified: Mapped[bool] = mapped_column(
        default=False,
        nullable=False,
    )
    last_login: Mapped[Optional[datetime]] = mapped_column(
        nullable=True,
    )

    # Relationships
    contacts: Mapped[List[Contact]] = relationship(
        "Contact",
        back_populates="user",
        cascade="all, delete-orphan",
        lazy="select",
        order_by="Contact.contact_name",
    )
    roles: Mapped[List[Role]] = relationship(
        "Role",
        secondary=user_roles,
        back_populates="users",
        lazy="selectin",
        order_by="Role.name",
    )
    communities: Mapped[List[Community]] = relationship(
        "Community",
        secondary=user_communities,
        back_populates="members",
        lazy="selectin",
        order_by="Community.name",
    )
    contact_endorsements: Mapped[List[ContactEndorsement]] = relationship(
        "ContactEndorsement",
        back_populates="user",
        cascade="all, delete-orphan",
        lazy="select",
        order_by="ContactEndorsement.created_at.desc()",
    )
    owned_communities: Mapped[List[Community]] = relationship(
        "Community",
        primaryjoin="User.id == Community.owner_id",
        back_populates="owner",
        lazy="select",
        order_by="Community.name",
    )

    __table_args__ = (
        create_email_constraint("email"),
        create_phone_constraint("mobile_number"),
    )

    @classmethod
    def create(cls, data: UserCreate) -> User:
        """Create a new User from UserCreate data."""
        return cls(**data.__dict__)

    def __repr__(self) -> str:
        """Return string representation."""
        return f"User(id={self.id}, email={self.email})"

    @property
    def full_name(self) -> str:
        """Get user's full name."""
        return f"{self.first_name} {self.last_name}"

    def record_login(self) -> None:
        """Record current timestamp as last login."""
        self.last_login = datetime.now()

    def verify_email(self) -> None:
        """Mark email as verified."""
        self.email_verified = True

    def has_permission(self, permission: str) -> bool:
        """
        Check if user has specific permission through any role.

        Args:
            permission: Permission to check

        Returns:
            bool: Whether user has permission
        """
        return any(
            role.has_permission(permission) for role in self.roles if role.is_active
        )

    def is_member_of(self, community_id: int) -> bool:
        """
        Check if user is member of community.

        Args:
            community_id: ID of community

        Returns:
            bool: Whether user is member
        """
        return any(c.id == community_id for c in self.communities)

    def owns_community(self, community_id: int) -> bool:
        """
        Check if user owns community.

        Args:
            community_id: ID of community

        Returns:
            bool: Whether user is owner
        """
        return any(c.id == community_id for c in self.owned_communities)

    def has_role(self, role_name: str) -> bool:
        """
        Check if user has specific role.

        Args:
            role_name: Name of role

        Returns:
            bool: Whether user has role
        """
        return any(r.name == role_name for r in self.roles if r.is_active)


<<< Processing file: ./models/mixins.py >>>

"""Base mixins for SQLAlchemy models."""

from datetime import datetime
from typing import Optional, TypeVar
from sqlalchemy import Boolean, Integer, String, func
from sqlalchemy.orm import Mapped, mapped_column
from app.db.types import TZDateTime

T = TypeVar("T")


class TimestampMixin:
    """Mixin for adding timestamp fields to models."""

    created_at: Mapped[datetime] = mapped_column(
        TZDateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
        doc="Timestamp of creation",
    )
    updated_at: Mapped[Optional[datetime]] = mapped_column(
        TZDateTime(timezone=True),
        onupdate=func.now(),
        doc="Timestamp of last update",
    )


class ActiveMixin:
    """Mixin for adding active status to models."""

    is_active: Mapped[bool] = mapped_column(
        Boolean,
        default=True,
        nullable=False,
        doc="Whether the entity is currently active",
    )


class NameMixin:
    """Mixin for adding standardized name fields to models."""

    name: Mapped[str] = mapped_column(
        String(100),
        nullable=False,
        index=True,
        doc="Name of the entity",
    )
    description: Mapped[Optional[str]] = mapped_column(
        String(255),
        doc="Description of the entity",
    )


class SlugMixin:
    """Mixin for adding slug field to models."""

    slug: Mapped[str] = mapped_column(
        String(100),
        unique=True,
        index=True,
        nullable=False,
        doc="URL-friendly version of the name",
    )


class OrderMixin:
    """Mixin for adding sort order to models."""

    sort_order: Mapped[int] = mapped_column(
        Integer,
        default=0,
        nullable=False,
        doc="Position in display order",
    )


class VerificationMixin:
    """Mixin for adding verification status to models."""

    is_verified: Mapped[bool] = mapped_column(
        Boolean,
        default=False,
        nullable=False,
        doc="Whether the entity is verified",
    )
    verification_date: Mapped[Optional[datetime]] = mapped_column(
        TZDateTime(timezone=True),
        doc="When verification occurred",
    )
    verification_notes: Mapped[Optional[str]] = mapped_column(
        String(200),
        doc="Notes about verification",
    )


class VisibilityMixin:
    """Mixin for adding public/private visibility to models."""

    is_public: Mapped[bool] = mapped_column(
        Boolean,
        default=True,
        nullable=False,
        doc="Whether the entity is publicly visible",
    )


class CounterMixin:
    """Mixin for adding common counter fields to models."""

    total_count: Mapped[int] = mapped_column(
        Integer,
        default=0,
        nullable=False,
        doc="Total count of related items",
    )
    active_count: Mapped[int] = mapped_column(
        Integer,
        default=0,
        nullable=False,
        doc="Count of active related items",
    )


<<< Processing file: ./models/associations.py >>>

"""Association tables for model relationships."""

from sqlalchemy import Table, Column, Integer, ForeignKey
from app.db.database import Base

# Contact and Category association
contact_categories = Table(
    "contact_categories",
    Base.metadata,
    Column(
        "contact_id",
        Integer,
        ForeignKey("contacts.id", ondelete="CASCADE"),
        primary_key=True,
        index=True,
    ),
    Column(
        "category_id",
        Integer,
        ForeignKey("categories.id", ondelete="CASCADE"),
        primary_key=True,
        index=True,
    ),
)

# Contact and Service association
contact_services = Table(
    "contact_services",
    Base.metadata,
    Column(
        "contact_id",
        Integer,
        ForeignKey("contacts.id", ondelete="CASCADE"),
        primary_key=True,
        index=True,
    ),
    Column(
        "service_id",
        Integer,
        ForeignKey("services.id", ondelete="CASCADE"),
        primary_key=True,
        index=True,
    ),
)

# Community and Contact association
community_contacts = Table(
    "community_contacts",
    Base.metadata,
    Column(
        "community_id",
        Integer,
        ForeignKey("communities.id", ondelete="CASCADE"),
        primary_key=True,
        index=True,
    ),
    Column(
        "contact_id",
        Integer,
        ForeignKey("contacts.id", ondelete="CASCADE"),
        primary_key=True,
        index=True,
    ),
)

# User and Role association
user_roles = Table(
    "user_roles",
    Base.metadata,
    Column(
        "user_id",
        Integer,
        ForeignKey("users.id", ondelete="CASCADE"),
        primary_key=True,
        index=True,
    ),
    Column(
        "role_id",
        Integer,
        ForeignKey("roles.id", ondelete="CASCADE"),
        primary_key=True,
        index=True,
    ),
)

# User and Community association
user_communities = Table(
    "user_communities",
    Base.metadata,
    Column(
        "user_id",
        Integer,
        ForeignKey("users.id", ondelete="CASCADE"),
        primary_key=True,
        index=True,
    ),
    Column(
        "community_id",
        Integer,
        ForeignKey("communities.id", ondelete="CASCADE"),
        primary_key=True,
        index=True,
    ),
)

# Community relationships (self-referential)
community_relationships = Table(
    "community_relationships",
    Base.metadata,
    Column(
        "community_a_id",
        Integer,
        ForeignKey("communities.id", ondelete="CASCADE"),
        primary_key=True,
        index=True,
    ),
    Column(
        "community_b_id",
        Integer,
        ForeignKey("communities.id", ondelete="CASCADE"),
        primary_key=True,
        index=True,
    ),
)


<<< Processing file: ./models/__init__.py >>>

"""
Database models initialization module.

This module serves as the central point of access for all database models in the
application. It provides organized imports of model classes while preventing
circular dependencies. The module ensures proper initialization order and
maintains a clean interface for accessing models throughout the application.

The module also exports common database components like the Base class and
custom types, making them easily accessible to other parts of the application.
"""

from app.db.database import Base
from app.db.types import TZDateTime
from app.db.models.user import User
from app.db.models.role import Role
from app.db.models.community import Community, PrivacyLevel
from app.db.models.category import Category
from app.db.models.service import Service
from app.db.models.contact import Contact
from app.db.models.contact_endorsement import ContactEndorsement

# Version information
__version__ = "1.0.0"

# Export all models and related components
__all__ = [
    # Base classes and types
    "Base",
    "TZDateTime",
    # Models
    "User",
    "Role",
    "Community",
    "Category",
    "Service",
    "Contact",
    "ContactEndorsement",
    # Enums and Constants
    "PrivacyLevel",
]

# Model dependencies for reference
model_dependencies = {
    "User": ["Role", "Community", "Contact", "ContactEndorsement"],
    "Role": ["User"],
    "Community": ["User", "Contact", "ContactEndorsement"],
    "Category": ["Contact", "Service"],
    "Service": ["Category", "Contact"],
    "Contact": ["User", "Community", "Category", "Service", "ContactEndorsement"],
    "ContactEndorsement": ["User", "Community", "Contact"],
}


def get_model_class(model_name: str) -> type:
    """
    Get a model class by its name.

    This function provides a way to dynamically access model classes,
    which can be useful for generic operations or dynamic model handling.

    Args:
        model_name: Name of the model class to retrieve

    Returns:
        The requested model class

    Raises:
        ValueError: If the model name is not recognized
    """
    models = {
        "User": User,
        "Role": Role,
        "Community": Community,
        "Category": Category,
        "Service": Service,
        "Contact": Contact,
        "ContactEndorsement": ContactEndorsement,
    }

    if model_name not in models:
        raise ValueError(f"Unknown model: {model_name}")

    return models[model_name]


<<< Processing file: ./models/role.py >>>

"""Role model definition module."""

from __future__ import annotations

from dataclasses import dataclass
import json
from typing import TYPE_CHECKING, List, Optional

from sqlalchemy import String
from sqlalchemy.orm import Mapped, relationship, mapped_column

from app.db.database import Base
from app.db.models.mixins import (
    TimestampMixin,
    ActiveMixin,
    NameMixin,
)
from app.db.models.associations import user_roles
from app.db.utils import (
    SHORT_STRING_LENGTH,
    COMMENT_LENGTH,
    create_check_constraint,
)

if TYPE_CHECKING:
    from app.db.models.user import User


@dataclass
class RoleCreate:
    """Data transfer object for creating a new Role."""

    name: str
    description: Optional[str] = None
    permissions: Optional[str] = None
    is_system_role: bool = False


class Role(TimestampMixin, ActiveMixin, NameMixin, Base):
    """
    Role model for user permissions.

    Defines sets of permissions and access levels that can be assigned to users.
    Supports both system-defined and custom roles.

    Attributes:
        id (int): Unique identifier
        name (str): Role name (unique)
        description (str, optional): Role description
        permissions (str, optional): JSON string of permissions
        is_system_role (bool): Whether this is a system-managed role
        is_active (bool): Whether role is currently active

    Relationships:
        users: Users assigned this role
    """

    __tablename__ = "roles"

    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(
        String(SHORT_STRING_LENGTH),
        unique=True,
        index=True,
        nullable=False,
    )
    permissions: Mapped[Optional[str]] = mapped_column(
        String(COMMENT_LENGTH),
        doc="JSON string containing role permissions",
    )
    is_system_role: Mapped[bool] = mapped_column(
        default=False,
        nullable=False,
        doc="Indicates if this is a system-managed role",
    )

    # Override from NameMixin for different length
    description: Mapped[Optional[str]] = mapped_column(
        String(COMMENT_LENGTH),
        doc="Detailed role description",
    )

    # Relationships
    users: Mapped[List[User]] = relationship(
        "User",
        secondary=user_roles,
        back_populates="roles",
        lazy="selectin",
        order_by="User.last_name",
    )

    __table_args__ = (
        create_check_constraint(
            "permissions IS NULL OR json_typeof(permissions::json) = 'array'",
            name="valid_permissions_json",
        ),
    )

    @classmethod
    def create(cls, data: RoleCreate) -> Role:
        """Create a new Role from RoleCreate data."""
        return cls(**data.__dict__)

    def __repr__(self) -> str:
        """Return string representation."""
        return f"Role(id={self.id}, name={self.name})"

    def has_permission(self, permission: str) -> bool:
        """
        Check if role has specific permission.

        Args:
            permission: Permission to check

        Returns:
            bool: Whether role has permission
        """
        if not self.permissions or not self.is_active:
            return False

        try:
            permissions = json.loads(self.permissions)
            return permission in permissions
        except (json.JSONDecodeError, TypeError):
            return False

    def grant_permission(self, permission: str) -> None:
        """
        Grant new permission to role.

        Args:
            permission: Permission to grant
        """
        try:
            permissions = json.loads(self.permissions) if self.permissions else []
        except (json.JSONDecodeError, TypeError):
            permissions = []

        if permission not in permissions:
            permissions.append(permission)
            self.permissions = json.dumps(permissions)

    def revoke_permission(self, permission: str) -> None:
        """
        Revoke permission from role.

        Args:
            permission: Permission to revoke
        """
        try:
            permissions = json.loads(self.permissions) if self.permissions else []
        except (json.JSONDecodeError, TypeError):
            return

        if permission in permissions:
            permissions.remove(permission)
            self.permissions = json.dumps(permissions)

    def list_permissions(self) -> List[str]:
        """
        Get list of all granted permissions.

        Returns:
            list: Current permissions
        """
        try:
            return json.loads(self.permissions) if self.permissions else []
        except (json.JSONDecodeError, TypeError):
            return []


<<< Processing file: ./models/community.py >>>

"""Community model definition module."""

from __future__ import annotations

import enum
from typing import TYPE_CHECKING, List, Optional
from dataclasses import dataclass

from sqlalchemy import ForeignKey, Integer, Enum as SQLAlchemyEnum
from sqlalchemy.orm import Mapped, relationship, mapped_column

from app.db.database import Base
from app.db.models.mixins import (
    TimestampMixin,
    ActiveMixin,
    NameMixin,
    CounterMixin,
)
from app.db.models.associations import (
    community_contacts,
    community_relationships,
    user_communities,
)

if TYPE_CHECKING:
    from app.db.models.user import User
    from app.db.models.contact import Contact
    from app.db.models.contact_endorsement import ContactEndorsement


class PrivacyLevel(str, enum.Enum):
    """Enumeration for community privacy levels."""

    PUBLIC = "public"
    PRIVATE = "private"
    INVITATION_ONLY = "invitation_only"


@dataclass
class CommunityCreate:
    """Data transfer object for creating a new Community."""

    name: str
    owner_id: int
    description: Optional[str] = None
    privacy_level: PrivacyLevel = PrivacyLevel.PUBLIC


class Community(
    TimestampMixin,
    ActiveMixin,
    NameMixin,
    CounterMixin,
    Base,
):
    """
    Community model for organizing users and contacts.

    Communities serve as organizational units that connect users and their contacts,
    enabling shared resources and collaborative endorsements.

    Attributes:
        id (int): Unique identifier
        name (str): Community name
        description (str, optional): Community description
        owner_id (int): ID of community owner
        privacy_level (PrivacyLevel): Access control level
        total_count (int): Total member count
        active_count (int): Active member count
        is_active (bool): Whether community is active

    Relationships:
        owner: User who owns the community
        members: Users who belong to community
        contacts: Contacts in the community
        related_communities: Connected communities
        contact_endorsements: Endorsements within community
    """

    __tablename__ = "communities"

    id: Mapped[int] = mapped_column(primary_key=True)
    owner_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
        doc="ID of community owner",
    )
    privacy_level: Mapped[PrivacyLevel] = mapped_column(
        SQLAlchemyEnum(PrivacyLevel, name="privacy_level_enum"),
        default=PrivacyLevel.PUBLIC,
        nullable=False,
        doc="Access control level",
    )

    # Relationships
    owner: Mapped[User] = relationship(
        "User",
        foreign_keys=[owner_id],
        back_populates="owned_communities",
        lazy="joined",
    )
    members: Mapped[List[User]] = relationship(
        "User",
        secondary=user_communities,
        back_populates="communities",
        lazy="selectin",
        order_by="User.last_name",
    )
    contacts: Mapped[List[Contact]] = relationship(
        "Contact",
        secondary=community_contacts,
        back_populates="communities",
        lazy="selectin",
        order_by="Contact.contact_name",
    )
    related_communities: Mapped[List[Community]] = relationship(
        "Community",
        secondary=community_relationships,
        primaryjoin=id == community_relationships.c.community_a_id,
        secondaryjoin=id == community_relationships.c.community_b_id,
        back_populates="related_to_communities",
        lazy="selectin",
        order_by="Community.name",
    )
    related_to_communities: Mapped[List[Community]] = relationship(
        "Community",
        secondary=community_relationships,
        primaryjoin=id == community_relationships.c.community_b_id,
        secondaryjoin=id == community_relationships.c.community_a_id,
        back_populates="related_communities",
        lazy="selectin",
        order_by="Community.name",
    )
    contact_endorsements: Mapped[List[ContactEndorsement]] = relationship(
        "ContactEndorsement",
        back_populates="community",
        cascade="all, delete-orphan",
        lazy="select",
    )

    @classmethod
    def create(cls, data: CommunityCreate) -> Community:
        """Create a new Community instance from CommunityCreate data."""
        return cls(**data.__dict__)

    def __repr__(self) -> str:
        """Return string representation."""
        return f"Community(id={self.id}, name={self.name})"

    def add_member(self, user: User) -> None:
        """
        Add a user as a member.

        Args:
            user: User to add

        Raises:
            ValueError: If user is already a member
        """
        if user in self.members:
            raise ValueError(f"User {user.id} is already a member")
        self.members.append(user)
        self.total_count += 1
        if user.is_active:
            self.active_count += 1

    def remove_member(self, user: User) -> None:
        """
        Remove a user from membership.

        Args:
            user: User to remove

        Raises:
            ValueError: If user is not a member
        """
        if user not in self.members:
            raise ValueError(f"User {user.id} is not a member")
        self.members.remove(user)
        self.total_count -= 1
        if user.is_active:
            self.active_count -= 1

    def add_related_community(self, community: Community) -> None:
        """
        Establish relationship with another community.

        Args:
            community: Community to relate to

        Raises:
            ValueError: If already related
        """
        if community in self.related_communities:
            raise ValueError(f"Already related to community {community.id}")
        self.related_communities.append(community)

    def can_user_access(self, user: Optional[User]) -> bool:
        """
        Check if a user can access this community.

        Args:
            user: User to check access for

        Returns:
            bool: Whether user has access
        """
        if self.privacy_level == PrivacyLevel.PUBLIC:
            return True
        if not user:
            return False
        if user.id == self.owner_id:
            return True
        return user in self.members


<<< Processing file: ./models/contact_endorsement.py >>>

"""Contact Endorsement model definition module."""

from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING, Optional
from sqlalchemy import (
    Boolean,
    Index,
    Integer,
    String,
    ForeignKey,
    text,
)
from sqlalchemy.orm import Mapped, relationship, mapped_column

from app.db.database import Base
from app.db.models.mixins import (
    TimestampMixin,
    VerificationMixin,
    VisibilityMixin,
)
from app.db.utils import (
    COMMENT_LENGTH,
    create_check_constraint,
    create_unique_constraint,
)

if TYPE_CHECKING:
    from app.db.models.user import User
    from app.db.models.community import Community
    from app.db.models.contact import Contact


@dataclass
class EndorsementCreate:
    """Data transfer object for creating a new ContactEndorsement."""

    contact_id: int
    user_id: int
    community_id: int
    endorsed: bool = True
    rating: Optional[int] = None
    comment: Optional[str] = None
    is_public: bool = True


class ContactEndorsement(
    TimestampMixin,
    VerificationMixin,
    VisibilityMixin,
    Base,
):
    """
    Model for contact endorsements within communities.

    Represents recommendations and ratings that users provide for contacts within
    specific communities. Includes verification status and visibility controls.

    Attributes:
        id (int): Unique identifier
        contact_id (int): ID of endorsed contact
        user_id (int): ID of endorsing user
        community_id (int): ID of community context
        endorsed (bool): Whether endorsement is positive
        rating (int, optional): Numerical rating (1-5)
        comment (str, optional): Detailed endorsement text
        is_verified (bool): Whether endorsement is verified
        verification_date (datetime): When endorsement was verified
        verification_notes (str, optional): Notes about verification
        is_public (bool): Whether endorsement is publicly visible

    Relationships:
        user: User who provided endorsement
        community: Community context
        contact: Contact being endorsed
    """

    __tablename__ = "contact_endorsements"

    id: Mapped[int] = mapped_column(primary_key=True)
    contact_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("contacts.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    user_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    community_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("communities.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    endorsed: Mapped[bool] = mapped_column(
        Boolean,
        default=True,
        nullable=False,
        doc="Indicates if this is a positive endorsement",
    )
    rating: Mapped[Optional[int]] = mapped_column(
        Integer,
        doc="Optional rating from 1 to 5",
    )
    comment: Mapped[Optional[str]] = mapped_column(
        String(COMMENT_LENGTH),
        doc="Optional detailed endorsement comment",
    )

    # Relationships
    user: Mapped[User] = relationship(
        "User",
        back_populates="contact_endorsements",
        lazy="joined",
    )
    community: Mapped[Community] = relationship(
        "Community",
        back_populates="contact_endorsements",
        lazy="joined",
    )
    contact: Mapped[Contact] = relationship(
        "Contact",
        back_populates="endorsements",
        lazy="joined",
    )

    __table_args__ = (
        create_unique_constraint(
            "user_id",
            "contact_id",
            "community_id",
            name="uq_user_contact_community_endorsement",
        ),
        create_check_constraint(
            "rating IS NULL OR (rating >= 1 AND rating <= 5)",
            name="valid_rating_range",
        ),
        # Optimize verified endorsement queries
        Index(
            "idx_contact_endorsements_verified",
            "contact_id",
            "is_verified",
            "rating",
            postgresql_where=text("is_verified = true"),
        ),
        # Optimize community-based endorsement queries with included columns
        # The INCLUDE clause adds columns to the index leaf nodes without making them part of the key
        Index(
            "idx_contact_endorsements_community",
            "community_id",
            "created_at",
            postgresql_include=["rating", "is_verified"],
        ),
    )

    @classmethod
    def create(cls, data: EndorsementCreate) -> ContactEndorsement:
        """Create a new ContactEndorsement from EndorsementCreate data."""
        return cls(**data.__dict__)

    def __repr__(self) -> str:
        """Return string representation."""
        return (
            f"ContactEndorsement(id={self.id}, "
            f"contact_id={self.contact_id}, "
            f"user_id={self.user_id})"
        )

    def update_rating(
        self,
        new_rating: Optional[int],
        comment: Optional[str] = None,
    ) -> None:
        """
        Update rating and optionally comment.

        Args:
            new_rating: New rating value (1-5) or None
            comment: Optional new comment text

        Raises:
            ValueError: If rating is invalid
        """
        if new_rating is not None and not 1 <= new_rating <= 5:
            raise ValueError("Rating must be between 1 and 5")

        self.rating = new_rating
        if comment is not None:
            self.comment = comment

    @property
    def verification_status(self) -> str:
        """Get human-readable verification status."""
        if not self.is_verified:
            return "Unverified"
        if self.verification_notes:
            return f"Verified with notes: {self.verification_notes}"
        return "Verified"

    @property
    def formatted_rating(self) -> Optional[str]:
        """Get formatted display of rating."""
        if self.rating is None:
            return None
        return f"{self.rating}/5 stars"


<<< Processing file: ./models/category.py >>>

"""Category model definition module.

This module implements the Category model, which provides a hierarchical classification
system for organizing services and contacts. It includes optimized database indices
for efficient tree traversal and hierarchical queries.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING, List, Optional

from sqlalchemy import Index, Integer, String, ForeignKey, text
from sqlalchemy.orm import Mapped, relationship, mapped_column, declared_attr

from app.db.database import Base
from app.db.models.associations import contact_categories
from app.db.models.mixins import (
    TimestampMixin,
    ActiveMixin,
    NameMixin,
    SlugMixin,
    OrderMixin,
)
from app.db.utils import DEFAULT_STRING_LENGTH

if TYPE_CHECKING:
    from app.db.models.contact import Contact
    from app.db.models.service import Service


@dataclass
class CategoryCreate:
    """Data transfer object for creating a new Category."""

    name: str
    slug: str
    description: Optional[str] = None
    parent: Optional[Category] = None
    sort_order: int = 0


class Category(
    TimestampMixin,
    ActiveMixin,
    NameMixin,
    SlugMixin,
    OrderMixin,
    Base,
):
    """
    Category model for hierarchical classification.

    Categories form a hierarchical structure for organizing contacts and services.
    Each category can have multiple child categories and belongs to a single
    parent category, enabling detailed taxonomies for resource classification.

    Attributes:
        id (int): Unique identifier
        name (str): Category name (unique)
        description (str, optional): Detailed category description
        slug (str): URL-friendly version of the name
        parent_id (int, optional): ID of parent category
        is_active (bool): Whether category is active
        sort_order (int): Display order position
        depth (int): Level in hierarchy (0 for root)
        path (str): Full path from root to this category
    """

    __tablename__ = "categories"

    # Primary Key
    id: Mapped[int] = mapped_column(primary_key=True)

    # Foreign Keys and Regular Columns
    parent_id: Mapped[Optional[int]] = mapped_column(
        Integer,
        ForeignKey("categories.id", ondelete="CASCADE"),
        index=True,
    )
    depth: Mapped[int] = mapped_column(
        Integer,
        default=0,
        nullable=False,
        doc="Level in hierarchy (0 for root)",
    )
    path: Mapped[str] = mapped_column(
        String(DEFAULT_STRING_LENGTH),
        nullable=False,
        doc="Full path from root to this category",
    )

    # Relationships
    parent: Mapped[Optional[Category]] = relationship(
        "Category",
        back_populates="children",
        remote_side=[id],
        lazy="joined",
    )
    children: Mapped[List[Category]] = relationship(
        "Category",
        back_populates="parent",
        cascade="all, delete-orphan",
        lazy="selectin",
        order_by="Category.sort_order",
    )
    contacts: Mapped[List[Contact]] = relationship(
        "Contact",
        secondary=contact_categories,
        back_populates="categories",
        lazy="selectin",
    )
    services: Mapped[List[Service]] = relationship(
        "Service",
        back_populates="category",
        cascade="all, delete-orphan",
        lazy="selectin",
        order_by="Service.name",
    )

    @declared_attr
    def __table_args__(cls) -> tuple:
        """Define table arguments including indices.

        Using declared_attr ensures proper column reference resolution
        and fixes linting issues.
        """
        return (
            # Optimize tree traversal queries
            Index(
                "uq_category_parent_slug",
                cls.parent_id,
                cls.slug,
                unique=True,
                postgresql_where=text("is_active = true"),
            ),
            # Improve hierarchical path lookups
            Index(
                "idx_categories_hierarchy",
                cls.path,
                cls.is_active,
                postgresql_using="btree",
            ),
            # Optimize level-based category queries
            Index(
                "idx_categories_depth",
                cls.depth,
                cls.is_active,
                postgresql_using="btree",
            ),
            # Improve sibling ordering queries
            Index(
                "idx_categories_ordering",
                cls.parent_id,
                cls.sort_order,
                cls.is_active,
                postgresql_using="btree",
            ),
            # Optimize path-based lookups
            Index(
                "idx_categories_path_search",
                cls.path,
                postgresql_using="btree",
                postgresql_where=text("is_active = true"),
            ),
        )

    @classmethod
    def create(cls, data: CategoryCreate) -> Category:
        """Create a new Category instance from CategoryCreate data."""
        instance = cls(**data.__dict__)
        instance.update_hierarchy_info()
        return instance

    def __repr__(self) -> str:
        """Return string representation."""
        return f"Category(id={self.id}, name={self.name})"

    def update_hierarchy_info(self) -> None:
        """Update hierarchy information (depth and path)."""
        if self.parent:
            self.depth = self.parent.depth + 1
            self.path = f"{self.parent.path}/{self.slug}"
        else:
            self.depth = 0
            self.path = self.slug

    def get_ancestors(self) -> List[Category]:
        """Get all ancestor categories in order from root to parent."""
        ancestors = []
        current = self.parent
        while current:
            ancestors.insert(0, current)
            current = current.parent
        return ancestors

    def get_descendants(self) -> List[Category]:
        """Get all descendant categories in depth-first order."""
        descendants = []
        for child in self.children:
            descendants.append(child)
            descendants.extend(child.get_descendants())
        return descendants

    def is_ancestor_of(self, category: Category) -> bool:
        """Check if this category is an ancestor of another category."""
        return self.path in category.path.split("/")

    def is_descendant_of(self, category: Category) -> bool:
        """Check if this category is a descendant of another category."""
        return category.path in self.path.split("/")

    def move_to_parent(self, new_parent: Optional[Category]) -> None:
        """Move this category to a new parent."""
        if new_parent and (self == new_parent or new_parent.is_descendant_of(self)):
            raise ValueError("Cannot move category to one of its descendants")

        self.parent = new_parent
        self.update_hierarchy_info()

        for descendant in self.get_descendants():
            descendant.update_hierarchy_info()

    def get_siblings(self) -> List[Category]:
        """Get all categories that share the same parent."""
        if self.parent:
            return [child for child in self.parent.children if child != self]
        return []

    def get_root(self) -> Category:
        """Get the root category for this branch of the hierarchy."""
        current = self
        while current.parent:
            current = current.parent
        return current

    def get_full_path_names(self) -> List[str]:
        """Get the full path of category names from root to this category."""
        path_names = []
        current = self
        while current:
            path_names.insert(0, current.name)
            current = current.parent
        return path_names

    def is_leaf(self) -> bool:
        """Check if this category is a leaf node (has no children)."""
        return len(self.children) == 0

    def is_empty(self) -> bool:
        """Check if this category has any associated contacts or services."""
        return len(self.contacts) == 0 and len(self.services) == 0

    def get_active_services_count(self) -> int:
        """Get count of active services in this category."""
        return sum(1 for service in self.services if service.is_active)

    def get_sorted_children(self, *, active_only: bool = False) -> List[Category]:
        """Get children categories in proper sort order."""
        children = self.children
        if active_only:
            children = [child for child in children if child.is_active]
        return sorted(children, key=lambda x: x.sort_order)

    def validate_hierarchy(self) -> bool:
        """Validate the correctness of the category hierarchy."""
        calculated_depth = self.get_hierarchy_level()
        if calculated_depth != self.depth:
            raise ValueError(
                f"Depth mismatch: stored={self.depth}, "
                f"calculated={calculated_depth}"
            )

        calculated_path = "/".join(
            ancestor.slug for ancestor in self.get_ancestors() + [self]
        )
        if calculated_path != self.path:
            raise ValueError(
                f"Path mismatch: stored={self.path}, " f"calculated={calculated_path}"
            )

        visited = set()
        current = self
        while current:
            if current.id in visited:
                raise ValueError("Circular reference detected in category hierarchy")
            visited.add(current.id)
            current = current.parent

        return True

    def get_hierarchy_level(self) -> int:
        """Get the absolute level in the full category hierarchy."""
        level = 0
        current = self.parent
        while current:
            level += 1
            current = current.parent
        return level

    def reorder_children(self, new_order: List[int]) -> None:
        """Reorder child categories based on provided order."""
        if set(new_order) != set(child.id for child in self.children):
            raise ValueError("New order must contain exactly the current child IDs")

        order_map = {id_: i for i, id_ in enumerate(new_order)}

        for child in self.children:
            child.sort_order = order_map[child.id]


<<< Processing file: ./models/contact.py >>>

"""Contact model definition module."""

from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING, List, Optional

from sqlalchemy import Index, Integer, String, ForeignKey, text
from sqlalchemy.orm import Mapped, relationship, mapped_column
from sqlalchemy.ext.hybrid import hybrid_property

from app.db.database import Base
from app.db.types import create_email_check_constraint
from app.db.utils import (
    EMAIL_LENGTH,
    NAME_LENGTH,
    PHONE_LENGTH,
    SHORT_STRING_LENGTH,
    create_phone_constraint,
)
from app.db.models.mixins import TimestampMixin, ActiveMixin
from app.db.models.associations import (
    contact_categories,
    contact_services,
    community_contacts,
)

if TYPE_CHECKING:
    from app.db.models.user import User
    from app.db.models.community import Community
    from app.db.models.category import Category
    from app.db.models.service import Service
    from app.db.models.contact_endorsement import ContactEndorsement


@dataclass
class ContactCreate:
    """Data transfer object for creating a new Contact."""

    user_id: int
    contact_name: str
    primary_contact_first_name: str
    primary_contact_last_name: str
    email: Optional[str] = None
    contact_number: Optional[str] = None
    primary_contact_contact_number: Optional[str] = None


class Contact(TimestampMixin, ActiveMixin, Base):
    """
    Contact model for service providers.

    Represents service providers in the system, maintaining their professional details,
    service offerings, and community relationships.

    Attributes:
        id (int): Unique identifier
        user_id (int): ID of creating user
        contact_name (str): Business/organization name
        email (str, optional): Primary email address
        contact_number (str, optional): Primary phone number
        primary_contact_first_name (str): First name of main contact
        primary_contact_last_name (str): Last name of main contact
        primary_contact_contact_number (str, optional): Direct number for main contact
        endorsements_count (int): Total endorsements received
        average_rating (float, optional): Average rating from endorsements
        verified_endorsements_count (int): Number of verified endorsements

    Relationships:
        user: Creating user
        communities: Associated communities
        categories: Service categories
        services: Offered services
        endorsements: Received endorsements
    """

    __tablename__ = "contacts"

    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    contact_name: Mapped[str] = mapped_column(
        String(NAME_LENGTH),
        nullable=False,
        index=True,
    )
    email: Mapped[Optional[str]] = mapped_column(
        String(EMAIL_LENGTH),
        unique=True,
        index=True,
    )
    contact_number: Mapped[Optional[str]] = mapped_column(String(PHONE_LENGTH))
    primary_contact_first_name: Mapped[str] = mapped_column(
        String(SHORT_STRING_LENGTH),
        nullable=False,
    )
    primary_contact_last_name: Mapped[str] = mapped_column(
        String(SHORT_STRING_LENGTH),
        nullable=False,
    )
    primary_contact_contact_number: Mapped[Optional[str]] = mapped_column(
        String(PHONE_LENGTH),
    )
    endorsements_count: Mapped[int] = mapped_column(
        Integer,
        default=0,
        nullable=False,
    )
    average_rating: Mapped[Optional[float]] = mapped_column(
        Integer,
        comment="Average rating out of 5",
    )
    verified_endorsements_count: Mapped[int] = mapped_column(
        Integer,
        default=0,
        nullable=False,
    )

    # Relationships
    user: Mapped[User] = relationship(
        "User",
        back_populates="contacts",
        lazy="joined",
    )
    communities: Mapped[List[Community]] = relationship(
        "Community",
        secondary=community_contacts,
        back_populates="contacts",
        lazy="selectin",
        order_by="Community.name",
    )
    categories: Mapped[List[Category]] = relationship(
        "Category",
        secondary=contact_categories,
        back_populates="contacts",
        lazy="selectin",
        order_by="Category.name",
    )
    services: Mapped[List[Service]] = relationship(
        "Service",
        secondary=contact_services,
        back_populates="contacts",
        lazy="selectin",
        order_by="Service.name",
    )
    endorsements: Mapped[List[ContactEndorsement]] = relationship(
        "ContactEndorsement",
        back_populates="contact",
        cascade="all, delete-orphan",
        lazy="select",
    )

    __table_args__ = (
        create_email_check_constraint("email"),
        create_phone_constraint("contact_number"),
        create_phone_constraint("primary_contact_contact_number"),
        # Combined index for name-based searches
        # This improves performance when searching by full name or sorting by name
        Index(
            "idx_contacts_primary_contact_name",
            "primary_contact_last_name",
            "primary_contact_first_name",
        ),
        # Trigram index for fuzzy contact name searches
        # Note: This requires the pg_trgm extension to be installed
        Index(
            "idx_contacts_contact_name_trgm",
            text("contact_name gin_trgm_ops"),
            postgresql_using="gin",
        ),
        # Composite index for endorsement-related queries
        # This speeds up queries that filter by endorsement counts and ratings
        Index(
            "idx_contacts_endorsement_metrics",
            "endorsements_count",
            "average_rating",
            "verified_endorsements_count",
            "is_active",
        ),
    )

    @classmethod
    def create(cls, data: ContactCreate) -> Contact:
        """Create a new Contact from ContactCreate data."""
        return cls(**data.__dict__)

    def __repr__(self) -> str:
        """Return string representation."""
        return f"Contact(id={self.id}, name={self.contact_name})"

    @hybrid_property
    def primary_contact_full_name(self) -> str:
        """Get full name of primary contact person."""
        return f"{self.primary_contact_first_name} {self.primary_contact_last_name}"

    def add_endorsement(self, endorsement: ContactEndorsement) -> None:
        """
        Add endorsement and update metrics.

        Args:
            endorsement: New endorsement to add
        """
        self.endorsements.append(endorsement)
        self.endorsements_count += 1

        if endorsement.is_verified:
            self.verified_endorsements_count += 1

        if endorsement.rating:
            self._update_average_rating()

    def remove_endorsement(self, endorsement: ContactEndorsement) -> None:
        """
        Remove endorsement and update metrics.

        Args:
            endorsement: Endorsement to remove
        """
        if endorsement in self.endorsements:
            self.endorsements.remove(endorsement)
            self.endorsements_count -= 1

            if endorsement.is_verified:
                self.verified_endorsements_count -= 1

            if endorsement.rating:
                self._update_average_rating()

    def _update_average_rating(self) -> None:
        """Update average rating based on current endorsements."""
        rated_endorsements = [e for e in self.endorsements if e.rating is not None]
        if rated_endorsements:
            total_rating = sum(e.rating for e in rated_endorsements)
            self.average_rating = round(total_rating / len(rated_endorsements), 1)
        else:
            self.average_rating = None

    def verify_endorsement(self, endorsement: ContactEndorsement) -> None:
        """
        Mark endorsement as verified.

        Args:
            endorsement: Endorsement to verify

        Raises:
            ValueError: If endorsement doesn't belong to this contact
        """
        if endorsement not in self.endorsements:
            raise ValueError("Endorsement does not belong to this contact")

        if not endorsement.is_verified:
            endorsement.is_verified = True
            self.verified_endorsements_count += 1

    def get_services_by_category(self, category_id: int) -> List[Service]:
        """Get all services in specified category."""
        return [s for s in self.services if s.category_id == category_id]

    def is_endorsed_in_community(self, community_id: int) -> bool:
        """Check if contact has endorsements in specified community."""
        return any(e.community_id == community_id for e in self.endorsements)


<<< Processing file: ./utils.py >>>

"""Database utility functions and constants."""

from typing import Optional
from sqlalchemy import (
    Boolean,
    Column,
    Integer,
    String,
    ForeignKey,
    CheckConstraint,
    UniqueConstraint,
)

# Common column lengths
DEFAULT_STRING_LENGTH = 255
SHORT_STRING_LENGTH = 50
MEDIUM_STRING_LENGTH = 100
LONG_STRING_LENGTH = 500
NAME_LENGTH = 100
DESCRIPTION_LENGTH = 255
COMMENT_LENGTH = 500
PHONE_LENGTH = 20
EMAIL_LENGTH = 255
POSTAL_LENGTH = 200
SLUG_LENGTH = 100


def create_foreign_key_column(
    target_table: str,
    *,
    nullable: bool = False,
    primary_key: bool = False,
    unique: bool = False,
    index: bool = True,
    doc: Optional[str] = None,
    ondelete: str = "CASCADE",
    name: Optional[str] = None,
) -> Column:
    """Create a standardized foreign key column.

    Args:
        target_table: Name of the referenced table
        nullable: Whether the column can be NULL
        primary_key: Whether this is a primary key
        unique: Whether values must be unique
        index: Whether to create an index
        doc: Column documentation
        ondelete: ON DELETE behavior ("CASCADE", "SET NULL", etc)
        name: Optional custom column name

    Returns:
        SQLAlchemy Column instance
    """
    column_name = name or f"{target_table.rstrip('s')}_id"
    return Column(
        column_name,
        Integer,
        ForeignKey(f"{target_table}.id", ondelete=ondelete),
        nullable=nullable,
        primary_key=primary_key,
        unique=unique,
        index=index,
        doc=doc,
    )


def create_string_column(
    length: int = DEFAULT_STRING_LENGTH,
    *,
    nullable: bool = True,
    unique: bool = False,
    index: bool = False,
    doc: Optional[str] = None,
) -> Column:
    """Create a standardized string column.

    Args:
        length: Maximum string length
        nullable: Whether the column can be NULL
        unique: Whether values must be unique
        index: Whether to create an index
        doc: Column documentation

    Returns:
        SQLAlchemy Column instance
    """
    return Column(
        String(length),
        nullable=nullable,
        unique=unique,
        index=index,
        doc=doc,
    )


def create_boolean_column(
    *,
    default: bool = False,
    nullable: bool = False,
    doc: Optional[str] = None,
) -> Column:
    """Create a standardized boolean column.

    Args:
        default: Default value if not specified
        nullable: Whether the column can be NULL
        doc: Column documentation

    Returns:
        SQLAlchemy Column instance
    """
    return Column(
        Boolean,
        default=default,
        nullable=nullable,
        doc=doc,
    )


def create_unique_constraint(
    *columns: str,
    name: Optional[str] = None,
) -> UniqueConstraint:
    """Create a named unique constraint.

    Args:
        *columns: Column names to include in constraint
        name: Optional constraint name

    Returns:
        SQLAlchemy UniqueConstraint instance
    """
    if name is None:
        name = f"uq_{'_'.join(columns)}"
    return UniqueConstraint(*columns, name=name)


def create_check_constraint(
    condition: str,
    name: Optional[str] = None,
) -> CheckConstraint:
    """Create a named check constraint.

    Args:
        condition: Check condition expression
        name: Optional constraint name

    Returns:
        SQLAlchemy CheckConstraint instance
    """
    return CheckConstraint(condition, name=name)


def validate_phone_number(value: Optional[str]) -> Optional[str]:
    """Validate and format a phone number.

    Args:
        value: Phone number to validate

    Returns:
        Formatted phone number or None

    Raises:
        ValueError: If phone number is invalid
    """
    if not value:
        return None

    # Remove any non-digit characters
    digits = "".join(filter(str.isdigit, value))

    # Basic validation - should be between 10 and 15 digits
    if not 10 <= len(digits) <= 15:
        raise ValueError("Phone number must be between 10 and 15 digits")

    return digits


def create_phone_constraint(column: str) -> CheckConstraint:
    """Create a check constraint for phone numbers.

    Args:
        column: Name of the phone number column

    Returns:
        SQLAlchemy CheckConstraint instance
    """
    return CheckConstraint(
        f"length(regexp_replace({column}, '[^0-9]', '', 'g')) BETWEEN 10 AND 15",
        name=f"valid_{column}_format",
    )


def create_email_constraint(column: str) -> CheckConstraint:
    """Create a check constraint for email addresses.

    Args:
        column: Name of the email column

    Returns:
        SQLAlchemy CheckConstraint instance
    """
    return CheckConstraint(
        f"{column} ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+[.][A-Za-z]{{2,}}$'",
        name=f"valid_{column}_format",
    )

